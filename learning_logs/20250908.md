```python
class Student:
    def __init__(self, name, student_id):
        self.name: name
        self._student_id = student_id
        # 성적을 저장하기 위한 빈 딕셔너리 -> 과목명이 key, 점수가 value가 되겠네요
        self._grades = {}
```

1. 지난 복습 시간에 Java version의 setter / getter를 생성했습니다.
    - 그런데 Java에는 access modifier 개념이 있었기 때문에 field를 private으로 선언했다면 setter / getter는 그냥 필수적이라고 봐도 됩니다.
    - 문제는 python에는 access modifier라고 할만한 개념이 없기 때문에 모든 객체의 속성이 외부로 노출됩니다.
2. 이상을 이유로 python에서는 `_속성명` 이라고 명시하게 되면, '내부적으로만 사용하라고 권장되는 변수'라고 개발자들끼리 약속한 개념에 가깝습니다.
3. name vs. _name
    - name
      - 공개적으로 접근 가능한 속성(Public Attribute)
      - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며, 다른 개발자가 이 변수를 직접 사용해도 괜찮음
      - `예시 : student.name = '김일'`과 같이 직접 접근하여 사용
    - _name
      - 내부용, 또는 비공개 속성(Private Attribute)
      - python에는 Java와 같은 엄격한 접근 제어자가 없기 때문에 _를 붙여서 '외부에서 접근하지 마세요'와 같은 의미만 전달.
      - 이런 변수는 일반적으로 `@property` 데코레이터를 사용한 getter와 setter를 경유하여 간접적으로 접근하는 것이 올바른 방법.

# JPA에서의 객체 생성 vs. python에서의 객체 생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제합니다(springboot에서도 적용됩니다). 그런데 python에서는 매개변수 생성자를 '권장'하는데, 이는 두 언어 간의 객체지향 패러다임과 데이터 관리 방식의 차이에 기인합니다.

1. Java(JPA)에서의 기본 생성자
    - JPA는 DB의 테이블과 (엔티티)클래스를 매핑하여 객체를 관리합니다(추후 수업할거지만 제가 이미 이야기한대로라면 엔티티 클래스의 field가 DB에서의 컬럼명이 된다고 헀었습니다). 이 과정에서 JPA가 지가 직접 매개변수를 알 수는 없기 때문에 매개변수가 없는 기본 생성자를 먼저 호출하여 객체를 생성하고, DB에서의 컬럼 값들을 하나씩 필드에 집어넣어줍니다. 이상을 이유로 JPA는 데이터 관리의 일관성과 효율성을 위해 기본 생성자를 강제합니다.
```java
@Entity
@Data
public class Student {
    private String name;
    private int studentCode;
    
    // 기본 생성자가 강제됨
    public Student(){}
}

public class StudentMain {
    main {
        Student student1 = new Student();
        student1.setName('김일');
        student1.setStudentCode(2025001);
    }
}
```
이상의 코드라인처럼 일단 필드에 아무런 값이 없는 객체를 생성한 후에, DB 상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해서 집어넣어주는 과정을 거치기 때문에 기본 생성자를 강제합니다.

2. python에서의 매개변수 생성자
   - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서, 객체를 생성할 때 필수 속성들을 한 번에 초기화하는 것을 권장합니다.
    1. 객체 무결성 보장 : init 메서드(생성자겠네요)에서 모든 필수 매개변수를 받으면, 객체가 생성되는 시점에 이미 완전한 상태를 갖게 됩니다. -> 그 값이 적절한가는 추후에 따져야 하지만.
    2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지를 명확하게 알 수 있습니다. Java처럼 순서대로 하는 것도 아니고 keyword argument를 지원하기도 하니까요.

그리고 python과 db의 연동에 있어서 JPA처럼 값을 하나씩 집어넣기 보다는 ORM(Object-Relational Mapping) 라이브러리를 통해서 객체를 생성할 때 필요한 데이터를 직접 전달하는 방식으로 JPA와의 차이점이 있어 기본 생성자를 강제할 필요가 없습니다.

* 요약 : JPA는 DB와 연동하기 위한 기술적 제약으로 인해 기본 생성자를 명시해야하는 귀찮은 점이 있는데(매개변수 생성자를 하나라도 정의하는 순간 기본 생성자도 정의해야 하니까요. 그게 귀찮으면 롬복에서 @NoArgsConstructor를 쓰겠지), python은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 더 권장합니다.


```python
MENU = {
    '에스프레소': {
        '재료': {
            '물': 50,
            '커피': 18,
        },
        '가격': 1.5,
    },
    '라떼': {
        '재료': {
            '물': 200,
            '우유': 150,
            '커피': 24,
        },
        '가격': 2.5,
    },
    '카푸치노': {
        '재료': {
            '물': 250,
            '우유': 100,
            '커피': 24,
        },
        '가격': 3.0,
    },
}

# 실행 예
# 카푸치노에는 우유가 100ml가 들어갑니다.
# 라고 콘솔에 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드를 작성하시오.
print(f'카푸치노에는 우유가 {MENU['카푸치노']['재료']['우유']}ml가 들어갑니다.')
# 에스프레소의 가격을 추출하시오.
print(MENU['에스프레소']['가격'])
# 라뗴의 재료를 재료 이름만 출력하시오.
for key in MENU['라떼']['재료']:        # dictionary에서 반복문을 돌리게 되면 key가 나온다 그리고 그 key를 이용해서 value 조회 가능
    print(key, end=' ')

print()

print(' '.join(MENU['라떼']['재료'].keys()))

'''
에스프레소 / 라떼 / 카푸치노를 50잔씩 만든다고 가정했을 때 필요한
커피 / 우유 / 물의 양은 얼마인가?
'''


coffee = 0
milk = 0
water = 0

for key in MENU:    # 결과값 : 에스프레소 / 라떼 / 카푸치노
    for key_key in MENU[key]['재료']:
        print(MENU[key]['재료'][key_key])
        if key_key == '커피':
            coffee += MENU[key]['재료'][key_key]
        elif key_key == '물':
            water += MENU[key]['재료'][key_key]
        else:
            milk += MENU[key]['재료'][key_key]

print(coffee*50)
print(water*100)
print(milk*100)


'''
이상의 학습 과정에서 중요한 부분은 중첩적으로 이루어진 dictionary - JSON - 기타 collections들이 합쳐진 데이터에서 내가 필요한 부분을 어떻게 추출할 수 있을까 입니다.

일반적으로는 list의 경우 index를 이용하기 때문에 반복문 쓰고 치우면 그만인데 반해 dictionary는 반복문을 돌리면 key가 나오게 되고, 그 key를 또 이용해야지만 value가 추출됩니다.

그리고 그 value를 이용해서 연산을 하거나 로직을 작성해야 하죠.

근데 value가 또 dictionary거나 list거나 혹은 객체거나 한 경우에는 좀 복잡해집니다.
이를 연습하기 위한 수업이었고, coffee_machine을 작성하면서는 중첩 dictionary를 활용하도록 하겠습니다.
'''
```
14:10부터 시험 대비 자습
15:00부터 취업 담당자님 초기 면담
16:30에 시험 문제 및 유형 공개

1과목 - 데이터 분속 기초 기술 활용이지만 그냥 python
서답형 때문에 지난번과 동일한 방식입니다.
차이점은 python 저희 리포지토리의 내용을 최대한 담았다는 점입니다. 그래서 로직 자체는 2과목에서 처리할 것이기 때문에 1과목은 되게 기본적인것들을 출제할 예정.

문제당 글자수가 끽해야 30자 내외입니다. 그래고 답변은 사실 상 한 단어에 가깝습니다.

call1() - call4()를 구분하는 방식은 명확하게 파악해두도록 하겠습니다.
문자열에서 공백을 기준으로 맨 앞 글자만 대문자로 바꿔주는 메서드를 작성하시오.

1 - Python에서 한 줄 주석을 작성할 때 사용하는 기호를 작성하세요. #

2과목 - 빅데이터 분석 결과 시각화
전체 4 문항 - 25/25/25/25

1 - 사용자로부터 전화번호를 입력받아, 특정 조건에 부합하는지 확인하고 전화번호의 중간 4자리를 출력하는 프로그램을 작성하시오. 전화번호는 하이픈(-)을 포함하여 총 13자리(예: 010-1234-5678)여야 합니다.

지시사항:

1. 사용자로부터 전화번호를 입력받으시오.
2. 입력된 전화번호의 길이가 13자리가 아닐 경우, "유효하지 않은 전화번호 형식입니다."라고 출력하시오.
3. 전화번호가 13자리일 경우, 전화번호의 중간 4자리(예: 1234)를 추출하여 출력하시오.
4. 출력 시 f-string을 사용하시오.

실행 예:
전화번호를 입력하시오 >>> 010-9876-5432 전화번호의 중간 4자리는 9876입니다.
전화번호를 입력하시오 >>> 010-123-4567 유효하지 않은 전화번호 형식입니다.

```python
phone = input("전화번호를 입력하세요 >>> ")

if len(phone) != 13:
    print('{phone} 유효하지 않은 전화번호 형식입니다.')
else :
    middle = phone[4:8]
    print('{phone} 전화번호의 중간 4자리는 {middle}입니다')
```

